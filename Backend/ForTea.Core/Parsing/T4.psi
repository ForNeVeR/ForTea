options {
  // Parser options
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  // Parser class name and namespace
  parserPackage="GammaJul.ForTea.Core.Parser";
  parserClassName="T4ParserGenerated";

  // Strongly type the lexer we're using. ILexer<int> is the caching lexer instance
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer";

  // FQN of (non-generated) class that provides messages for the parser
  parserMessagesClass="GammaJul.ForTea.Core.Parsing.ParserMessages";

  // Parser, error messages + token bitsets target folder
  parserTargetSubdir="Parsing";

  // Don't generate a bitset unless there's 4 or more comparisons to be made
  tokenBitsetThreshold=4;

  // Composite node type/element generation options
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  // Existing language specific ITreeNode
  "psiElementClassFQName"="GammaJul.ForTea.Core.Tree.IT4TreeNode";

  // Existing token type containing class + namespace
  tokenTypePackageName="GammaJul.ForTea.Core.Parsing";
  tokenTypeClassName="T4TokenNodeTypes";

  // Set base index for generated (element, not token) node types. Defaults to 2000, tokens default to 1000
  // tokenTypeBaseIndex=2000;

  // Tree node interface namespace + target folder (also target folder for navigators + visitors)
  psiInterfacePackageName="GammaJul.ForTea.Core.Tree";
  psiInterfacesTargetSubdir="Tree";

  // Tree node implementation namespace, base type and target folder
  psiStubsPackageName="GammaJul.ForTea.Core.Tree.Impl";
  psiStubsBaseClass="T4CompositeElement";
  psiStubsTargetSubdir="Tree/Impl";

  // Existing composite node type base class
  elementTypeBaseClass="T4CompositeNodeType";

  // Namespace for generating custom interface when `customInterface` option used
  customInterfacePackage="GammaJul.ForTea.Core.Tree.Custom";

  // Any role used in this file that begins with this prefix must be defined in `ChildRole`
  publicChildRolePrefix="T4_";

  // Namespace and suffix for custom element instance implementation created by
  // node type when `customImpl` option is specfied.
  // Default suffix is `Impl`
  customImplPackage="GammaJul.ForTea.Core.Tree.Impl";
  "customImplSuffix"="";

  // Required on. Changes behaviour of various things, e.g. public child role values based on prefix
  disableReflection;

  // Required. If missing, generates Add/Remove methods for each collection
  generateWorkingPsi;

  "psiClassesPrefix"="";
  "psiClassPrefix"="T4";
  "interfaceNamePrefix"="I";
  "objectClassFQName"="System.Object";
}

t4File options { stubBase="T4FileBase"; customParseFunction; }
:
    (t4Block<BLOCK, Blocks> | RAW_TEXT<RAW_TEXT, RawTexts> | NEW_LINE<NEW_LINE, NewLines>)*
;

// ---- ---- ---- ---- blocks ---- ---- ---- ----

errorhandling interface t4Block:
    t4Directive | t4CodeBlock
;

interface t4CodeBlock:
    t4StatementBlock | t4ExpressionBlock | t4FeatureBlock
;

t4StatementBlock:
    STATEMENT_BLOCK_START<STATEMENT_BLOCK_START, Start>
    t4Code<CODE, Code>
    BLOCK_END<BLOCK_END, End>
;

t4ExpressionBlock:
    EXPRESSION_BLOCK_START<EXPRESSION_BLOCK_START, Start>
    t4Code<CODE, Code>
    BLOCK_END<BLOCK_END, End>
;

t4FeatureBlock:
    FEATURE_BLOCK_START<FEATURE_BLOCK_START, Start>
    t4Code<CODE, Code>
    BLOCK_END<BLOCK_END, End>
;

// ---- ---- ---- ---- directives ---- ---- ---- ----

// All these directives have same start,
// and generated parser seems to only take into account one lookahead token,
// so we have to do that manually.
// I really wish there was a simpler way of doing that

interface t4Directive options { customParseFunction; noInternalParseFunction; }:
      t4TemplateDirective
    | t4ParameterDirective
    | t4OutputDirective
    | t4AssemblyDirective
    | t4ImportDirective
    | t4IncludeDirective
    | t4CleanupBehaviorDirective
    | t4UnknownDirective 
;

t4TemplateDirective:
    DIRECTIVE_START<DIRECTIVE_START, Start>
    TEMPLATE<TEMPLATE, Name>
    t4DirectiveAttribute<DIRECTIVE_ATTRIBUTE, Attributes>*
    BLOCK_END<BLOCK_END, End>
;

t4ParameterDirective:
    DIRECTIVE_START<DIRECTIVE_START, Start>
    PARAMETER<PARAMETER, Name>
    t4DirectiveAttribute<DIRECTIVE_ATTRIBUTE, Attributes>*
    BLOCK_END<BLOCK_END, End>
;

t4OutputDirective:
    DIRECTIVE_START<DIRECTIVE_START, Start>
    OUTPUT<OUTPUT, Name>
    t4DirectiveAttribute<DIRECTIVE_ATTRIBUTE, Attributes>*
    BLOCK_END<BLOCK_END, End>
;

t4AssemblyDirective:
    DIRECTIVE_START<DIRECTIVE_START, Start>
    ASSEMBLY<ASSEMBLY, Name>
    t4DirectiveAttribute<DIRECTIVE_ATTRIBUTE, Attributes>*
    BLOCK_END<BLOCK_END, End>
;

t4ImportDirective:
    DIRECTIVE_START<DIRECTIVE_START, Start>
    IMPORT<IMPORT, Name>
    t4DirectiveAttribute<DIRECTIVE_ATTRIBUTE, Attributes>*
    BLOCK_END<BLOCK_END, End>
;

t4IncludeDirective:
    DIRECTIVE_START<DIRECTIVE_START, Start>
    INCLUDE<INCLUDE, Name>
    t4DirectiveAttribute<DIRECTIVE_ATTRIBUTE, Attributes>*
    BLOCK_END<BLOCK_END, End>
;

t4CleanupBehaviorDirective:
    DIRECTIVE_START<DIRECTIVE_START, Start>
    CLEANUP_BEHAVIOR<CLEANUP_BEHAVIOR, Name>
    t4DirectiveAttribute<DIRECTIVE_ATTRIBUTE, Attributes>*
    BLOCK_END<BLOCK_END, End>
;

t4UnknownDirective:
    DIRECTIVE_START<DIRECTIVE_START, Start>
    UNKNOWN_DIRECTIVE_NAME<UNKNOWN_DIRECTIVE_NAME, Name>
    t4DirectiveAttribute<DIRECTIVE_ATTRIBUTE, Attributes>*
    BLOCK_END<BLOCK_END, End>
;

t4DirectiveAttribute:
    TOKEN<TOKEN, Name>
    EQUAL<EQUAL, Equal>
    QUOTE<QUOTE, OpeningQuote>
    t4AttributeValue<DIRECTIVE_ATTRIBUTE_VALUE, Value>
    QUOTE<QUOTE, ClosingQuote>
;

t4AttributeName:
    TOKEN<TOKEN, Token>
;

// ---- ---- ---- ---- raw values ---- ---- ---- ----

t4Code:
    RAW_CODE<RAW_CODE, RawCodes>*
;

// Macros will be inserted here
t4AttributeValue:
    ( RAW_ATTRIBUTE_VALUE<RAW_ATTRIBUTE_VALUE, RawAttributeValues>
    | t4Macro<t4Macro, Macros>
    | t4EnvironmentVariable<t4EnvironmentVariable, EnvironmentVariables>
    )*
;

t4Macro:
    DOLLAR<DOLLAR, Dollar>
    LEFT_PARENTHESIS<LEFT_PARENTHESIS, LeftParenthesis>
    RAW_ATTRIBUTE_VALUE<RAW_ATTRIBUTE_VALUE, RawAttributeValue>
    RIGHT_PARENTHESIS<RIGHT_PARENTHESIS, RightParenthesis>
;

t4EnvironmentVariable:
    PERCENT<PERCENT, StartPercent>
    RAW_ATTRIBUTE_VALUE<RAW_ATTRIBUTE_VALUE, RawAttributeValue>
    PERCENT<PERCENT, EndPercent>
;
